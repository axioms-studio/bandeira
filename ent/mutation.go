// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/felipekafuri/bandeira/ent/apitoken"
	"github.com/felipekafuri/bandeira/ent/constraint"
	"github.com/felipekafuri/bandeira/ent/environment"
	"github.com/felipekafuri/bandeira/ent/flag"
	"github.com/felipekafuri/bandeira/ent/flagenvironment"
	"github.com/felipekafuri/bandeira/ent/predicate"
	"github.com/felipekafuri/bandeira/ent/project"
	"github.com/felipekafuri/bandeira/ent/strategy"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiToken        = "ApiToken"
	TypeConstraint      = "Constraint"
	TypeEnvironment     = "Environment"
	TypeFlag            = "Flag"
	TypeFlagEnvironment = "FlagEnvironment"
	TypeProject         = "Project"
	TypeStrategy        = "Strategy"
)

// ApiTokenMutation represents an operation that mutates the ApiToken nodes in the graph.
type ApiTokenMutation struct {
	config
	op             Op
	typ            string
	id             *int
	secret         *string
	plain_token    *string
	name           *string
	token_type     *apitoken.TokenType
	environment    *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*ApiToken, error)
	predicates     []predicate.ApiToken
}

var _ ent.Mutation = (*ApiTokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*ApiTokenMutation)

// newApiTokenMutation creates new mutation for the ApiToken entity.
func newApiTokenMutation(c config, op Op, opts ...apitokenOption) *ApiTokenMutation {
	m := &ApiTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeApiToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiTokenID sets the ID field of the mutation.
func withApiTokenID(id int) apitokenOption {
	return func(m *ApiTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiToken
		)
		m.oldValue = func(ctx context.Context) (*ApiToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiToken sets the old ApiToken of the mutation.
func withApiToken(node *ApiToken) apitokenOption {
	return func(m *ApiTokenMutation) {
		m.oldValue = func(context.Context) (*ApiToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSecret sets the "secret" field.
func (m *ApiTokenMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *ApiTokenMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *ApiTokenMutation) ResetSecret() {
	m.secret = nil
}

// SetPlainToken sets the "plain_token" field.
func (m *ApiTokenMutation) SetPlainToken(s string) {
	m.plain_token = &s
}

// PlainToken returns the value of the "plain_token" field in the mutation.
func (m *ApiTokenMutation) PlainToken() (r string, exists bool) {
	v := m.plain_token
	if v == nil {
		return
	}
	return *v, true
}

// OldPlainToken returns the old "plain_token" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldPlainToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlainToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlainToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlainToken: %w", err)
	}
	return oldValue.PlainToken, nil
}

// ResetPlainToken resets all changes to the "plain_token" field.
func (m *ApiTokenMutation) ResetPlainToken() {
	m.plain_token = nil
}

// SetName sets the "name" field.
func (m *ApiTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApiTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApiTokenMutation) ResetName() {
	m.name = nil
}

// SetTokenType sets the "token_type" field.
func (m *ApiTokenMutation) SetTokenType(at apitoken.TokenType) {
	m.token_type = &at
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *ApiTokenMutation) TokenType() (r apitoken.TokenType, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldTokenType(ctx context.Context) (v apitoken.TokenType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *ApiTokenMutation) ResetTokenType() {
	m.token_type = nil
}

// SetEnvironment sets the "environment" field.
func (m *ApiTokenMutation) SetEnvironment(s string) {
	m.environment = &s
}

// Environment returns the value of the "environment" field in the mutation.
func (m *ApiTokenMutation) Environment() (r string, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironment returns the old "environment" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldEnvironment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironment: %w", err)
	}
	return oldValue.Environment, nil
}

// ClearEnvironment clears the value of the "environment" field.
func (m *ApiTokenMutation) ClearEnvironment() {
	m.environment = nil
	m.clearedFields[apitoken.FieldEnvironment] = struct{}{}
}

// EnvironmentCleared returns if the "environment" field was cleared in this mutation.
func (m *ApiTokenMutation) EnvironmentCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldEnvironment]
	return ok
}

// ResetEnvironment resets all changes to the "environment" field.
func (m *ApiTokenMutation) ResetEnvironment() {
	m.environment = nil
	delete(m.clearedFields, apitoken.FieldEnvironment)
}

// SetProjectID sets the "project_id" field.
func (m *ApiTokenMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ApiTokenMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ApiTokenMutation) ResetProjectID() {
	m.project = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ApiTokenMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[apitoken.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ApiTokenMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ApiTokenMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ApiTokenMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ApiTokenMutation builder.
func (m *ApiTokenMutation) Where(ps ...predicate.ApiToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiToken).
func (m *ApiTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiTokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.secret != nil {
		fields = append(fields, apitoken.FieldSecret)
	}
	if m.plain_token != nil {
		fields = append(fields, apitoken.FieldPlainToken)
	}
	if m.name != nil {
		fields = append(fields, apitoken.FieldName)
	}
	if m.token_type != nil {
		fields = append(fields, apitoken.FieldTokenType)
	}
	if m.environment != nil {
		fields = append(fields, apitoken.FieldEnvironment)
	}
	if m.project != nil {
		fields = append(fields, apitoken.FieldProjectID)
	}
	if m.created_at != nil {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apitoken.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldSecret:
		return m.Secret()
	case apitoken.FieldPlainToken:
		return m.PlainToken()
	case apitoken.FieldName:
		return m.Name()
	case apitoken.FieldTokenType:
		return m.TokenType()
	case apitoken.FieldEnvironment:
		return m.Environment()
	case apitoken.FieldProjectID:
		return m.ProjectID()
	case apitoken.FieldCreatedAt:
		return m.CreatedAt()
	case apitoken.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldSecret:
		return m.OldSecret(ctx)
	case apitoken.FieldPlainToken:
		return m.OldPlainToken(ctx)
	case apitoken.FieldName:
		return m.OldName(ctx)
	case apitoken.FieldTokenType:
		return m.OldTokenType(ctx)
	case apitoken.FieldEnvironment:
		return m.OldEnvironment(ctx)
	case apitoken.FieldProjectID:
		return m.OldProjectID(ctx)
	case apitoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apitoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApiToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case apitoken.FieldPlainToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlainToken(v)
		return nil
	case apitoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apitoken.FieldTokenType:
		v, ok := value.(apitoken.TokenType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case apitoken.FieldEnvironment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironment(v)
		return nil
	case apitoken.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case apitoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apitoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apitoken.FieldEnvironment) {
		fields = append(fields, apitoken.FieldEnvironment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiTokenMutation) ClearField(name string) error {
	switch name {
	case apitoken.FieldEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown ApiToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiTokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldSecret:
		m.ResetSecret()
		return nil
	case apitoken.FieldPlainToken:
		m.ResetPlainToken()
		return nil
	case apitoken.FieldName:
		m.ResetName()
		return nil
	case apitoken.FieldTokenType:
		m.ResetTokenType()
		return nil
	case apitoken.FieldEnvironment:
		m.ResetEnvironment()
		return nil
	case apitoken.FieldProjectID:
		m.ResetProjectID()
		return nil
	case apitoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apitoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, apitoken.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, apitoken.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apitoken.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiTokenMutation) ClearEdge(name string) error {
	switch name {
	case apitoken.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ApiToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiTokenMutation) ResetEdge(name string) error {
	switch name {
	case apitoken.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown ApiToken edge %s", name)
}

// ConstraintMutation represents an operation that mutates the Constraint nodes in the graph.
type ConstraintMutation struct {
	config
	op               Op
	typ              string
	id               *int
	context_name     *string
	operator         *constraint.Operator
	values           *[]string
	appendvalues     []string
	inverted         *bool
	case_insensitive *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	strategy         *int
	clearedstrategy  bool
	done             bool
	oldValue         func(context.Context) (*Constraint, error)
	predicates       []predicate.Constraint
}

var _ ent.Mutation = (*ConstraintMutation)(nil)

// constraintOption allows management of the mutation configuration using functional options.
type constraintOption func(*ConstraintMutation)

// newConstraintMutation creates new mutation for the Constraint entity.
func newConstraintMutation(c config, op Op, opts ...constraintOption) *ConstraintMutation {
	m := &ConstraintMutation{
		config:        c,
		op:            op,
		typ:           TypeConstraint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConstraintID sets the ID field of the mutation.
func withConstraintID(id int) constraintOption {
	return func(m *ConstraintMutation) {
		var (
			err   error
			once  sync.Once
			value *Constraint
		)
		m.oldValue = func(ctx context.Context) (*Constraint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Constraint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConstraint sets the old Constraint of the mutation.
func withConstraint(node *Constraint) constraintOption {
	return func(m *ConstraintMutation) {
		m.oldValue = func(context.Context) (*Constraint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConstraintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConstraintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConstraintMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConstraintMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Constraint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContextName sets the "context_name" field.
func (m *ConstraintMutation) SetContextName(s string) {
	m.context_name = &s
}

// ContextName returns the value of the "context_name" field in the mutation.
func (m *ConstraintMutation) ContextName() (r string, exists bool) {
	v := m.context_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContextName returns the old "context_name" field's value of the Constraint entity.
// If the Constraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstraintMutation) OldContextName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContextName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContextName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContextName: %w", err)
	}
	return oldValue.ContextName, nil
}

// ResetContextName resets all changes to the "context_name" field.
func (m *ConstraintMutation) ResetContextName() {
	m.context_name = nil
}

// SetOperator sets the "operator" field.
func (m *ConstraintMutation) SetOperator(c constraint.Operator) {
	m.operator = &c
}

// Operator returns the value of the "operator" field in the mutation.
func (m *ConstraintMutation) Operator() (r constraint.Operator, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old "operator" field's value of the Constraint entity.
// If the Constraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstraintMutation) OldOperator(ctx context.Context) (v constraint.Operator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ResetOperator resets all changes to the "operator" field.
func (m *ConstraintMutation) ResetOperator() {
	m.operator = nil
}

// SetValues sets the "values" field.
func (m *ConstraintMutation) SetValues(s []string) {
	m.values = &s
	m.appendvalues = nil
}

// Values returns the value of the "values" field in the mutation.
func (m *ConstraintMutation) Values() (r []string, exists bool) {
	v := m.values
	if v == nil {
		return
	}
	return *v, true
}

// OldValues returns the old "values" field's value of the Constraint entity.
// If the Constraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstraintMutation) OldValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValues: %w", err)
	}
	return oldValue.Values, nil
}

// AppendValues adds s to the "values" field.
func (m *ConstraintMutation) AppendValues(s []string) {
	m.appendvalues = append(m.appendvalues, s...)
}

// AppendedValues returns the list of values that were appended to the "values" field in this mutation.
func (m *ConstraintMutation) AppendedValues() ([]string, bool) {
	if len(m.appendvalues) == 0 {
		return nil, false
	}
	return m.appendvalues, true
}

// ResetValues resets all changes to the "values" field.
func (m *ConstraintMutation) ResetValues() {
	m.values = nil
	m.appendvalues = nil
}

// SetInverted sets the "inverted" field.
func (m *ConstraintMutation) SetInverted(b bool) {
	m.inverted = &b
}

// Inverted returns the value of the "inverted" field in the mutation.
func (m *ConstraintMutation) Inverted() (r bool, exists bool) {
	v := m.inverted
	if v == nil {
		return
	}
	return *v, true
}

// OldInverted returns the old "inverted" field's value of the Constraint entity.
// If the Constraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstraintMutation) OldInverted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInverted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInverted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInverted: %w", err)
	}
	return oldValue.Inverted, nil
}

// ResetInverted resets all changes to the "inverted" field.
func (m *ConstraintMutation) ResetInverted() {
	m.inverted = nil
}

// SetCaseInsensitive sets the "case_insensitive" field.
func (m *ConstraintMutation) SetCaseInsensitive(b bool) {
	m.case_insensitive = &b
}

// CaseInsensitive returns the value of the "case_insensitive" field in the mutation.
func (m *ConstraintMutation) CaseInsensitive() (r bool, exists bool) {
	v := m.case_insensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldCaseInsensitive returns the old "case_insensitive" field's value of the Constraint entity.
// If the Constraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstraintMutation) OldCaseInsensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaseInsensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaseInsensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaseInsensitive: %w", err)
	}
	return oldValue.CaseInsensitive, nil
}

// ResetCaseInsensitive resets all changes to the "case_insensitive" field.
func (m *ConstraintMutation) ResetCaseInsensitive() {
	m.case_insensitive = nil
}

// SetStrategyID sets the "strategy_id" field.
func (m *ConstraintMutation) SetStrategyID(i int) {
	m.strategy = &i
}

// StrategyID returns the value of the "strategy_id" field in the mutation.
func (m *ConstraintMutation) StrategyID() (r int, exists bool) {
	v := m.strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyID returns the old "strategy_id" field's value of the Constraint entity.
// If the Constraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstraintMutation) OldStrategyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyID: %w", err)
	}
	return oldValue.StrategyID, nil
}

// ResetStrategyID resets all changes to the "strategy_id" field.
func (m *ConstraintMutation) ResetStrategyID() {
	m.strategy = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConstraintMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConstraintMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Constraint entity.
// If the Constraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstraintMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConstraintMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConstraintMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConstraintMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Constraint entity.
// If the Constraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConstraintMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConstraintMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearStrategy clears the "strategy" edge to the Strategy entity.
func (m *ConstraintMutation) ClearStrategy() {
	m.clearedstrategy = true
	m.clearedFields[constraint.FieldStrategyID] = struct{}{}
}

// StrategyCleared reports if the "strategy" edge to the Strategy entity was cleared.
func (m *ConstraintMutation) StrategyCleared() bool {
	return m.clearedstrategy
}

// StrategyIDs returns the "strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *ConstraintMutation) StrategyIDs() (ids []int) {
	if id := m.strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "strategy" edge.
func (m *ConstraintMutation) ResetStrategy() {
	m.strategy = nil
	m.clearedstrategy = false
}

// Where appends a list predicates to the ConstraintMutation builder.
func (m *ConstraintMutation) Where(ps ...predicate.Constraint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConstraintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConstraintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Constraint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConstraintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConstraintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Constraint).
func (m *ConstraintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConstraintMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.context_name != nil {
		fields = append(fields, constraint.FieldContextName)
	}
	if m.operator != nil {
		fields = append(fields, constraint.FieldOperator)
	}
	if m.values != nil {
		fields = append(fields, constraint.FieldValues)
	}
	if m.inverted != nil {
		fields = append(fields, constraint.FieldInverted)
	}
	if m.case_insensitive != nil {
		fields = append(fields, constraint.FieldCaseInsensitive)
	}
	if m.strategy != nil {
		fields = append(fields, constraint.FieldStrategyID)
	}
	if m.created_at != nil {
		fields = append(fields, constraint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, constraint.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConstraintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case constraint.FieldContextName:
		return m.ContextName()
	case constraint.FieldOperator:
		return m.Operator()
	case constraint.FieldValues:
		return m.Values()
	case constraint.FieldInverted:
		return m.Inverted()
	case constraint.FieldCaseInsensitive:
		return m.CaseInsensitive()
	case constraint.FieldStrategyID:
		return m.StrategyID()
	case constraint.FieldCreatedAt:
		return m.CreatedAt()
	case constraint.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConstraintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case constraint.FieldContextName:
		return m.OldContextName(ctx)
	case constraint.FieldOperator:
		return m.OldOperator(ctx)
	case constraint.FieldValues:
		return m.OldValues(ctx)
	case constraint.FieldInverted:
		return m.OldInverted(ctx)
	case constraint.FieldCaseInsensitive:
		return m.OldCaseInsensitive(ctx)
	case constraint.FieldStrategyID:
		return m.OldStrategyID(ctx)
	case constraint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case constraint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Constraint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConstraintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case constraint.FieldContextName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContextName(v)
		return nil
	case constraint.FieldOperator:
		v, ok := value.(constraint.Operator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case constraint.FieldValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValues(v)
		return nil
	case constraint.FieldInverted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInverted(v)
		return nil
	case constraint.FieldCaseInsensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaseInsensitive(v)
		return nil
	case constraint.FieldStrategyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyID(v)
		return nil
	case constraint.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case constraint.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Constraint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConstraintMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConstraintMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConstraintMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Constraint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConstraintMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConstraintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConstraintMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Constraint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConstraintMutation) ResetField(name string) error {
	switch name {
	case constraint.FieldContextName:
		m.ResetContextName()
		return nil
	case constraint.FieldOperator:
		m.ResetOperator()
		return nil
	case constraint.FieldValues:
		m.ResetValues()
		return nil
	case constraint.FieldInverted:
		m.ResetInverted()
		return nil
	case constraint.FieldCaseInsensitive:
		m.ResetCaseInsensitive()
		return nil
	case constraint.FieldStrategyID:
		m.ResetStrategyID()
		return nil
	case constraint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case constraint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Constraint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConstraintMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.strategy != nil {
		edges = append(edges, constraint.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConstraintMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case constraint.EdgeStrategy:
		if id := m.strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConstraintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConstraintMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConstraintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstrategy {
		edges = append(edges, constraint.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConstraintMutation) EdgeCleared(name string) bool {
	switch name {
	case constraint.EdgeStrategy:
		return m.clearedstrategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConstraintMutation) ClearEdge(name string) error {
	switch name {
	case constraint.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown Constraint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConstraintMutation) ResetEdge(name string) error {
	switch name {
	case constraint.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown Constraint edge %s", name)
}

// EnvironmentMutation represents an operation that mutates the Environment nodes in the graph.
type EnvironmentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	_type                    *environment.Type
	sort_order               *int
	addsort_order            *int
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	project                  *int
	clearedproject           bool
	flag_environments        map[int]struct{}
	removedflag_environments map[int]struct{}
	clearedflag_environments bool
	done                     bool
	oldValue                 func(context.Context) (*Environment, error)
	predicates               []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows management of the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for the Environment entity.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the ID field of the mutation.
func withEnvironmentID(id int) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Environment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *EnvironmentMutation) SetType(e environment.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *EnvironmentMutation) GetType() (r environment.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldType(ctx context.Context) (v environment.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EnvironmentMutation) ResetType() {
	m._type = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *EnvironmentMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *EnvironmentMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *EnvironmentMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *EnvironmentMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *EnvironmentMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetProjectID sets the "project_id" field.
func (m *EnvironmentMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *EnvironmentMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *EnvironmentMutation) ResetProjectID() {
	m.project = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EnvironmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnvironmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnvironmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnvironmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnvironmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnvironmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *EnvironmentMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[environment.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *EnvironmentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *EnvironmentMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *EnvironmentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddFlagEnvironmentIDs adds the "flag_environments" edge to the FlagEnvironment entity by ids.
func (m *EnvironmentMutation) AddFlagEnvironmentIDs(ids ...int) {
	if m.flag_environments == nil {
		m.flag_environments = make(map[int]struct{})
	}
	for i := range ids {
		m.flag_environments[ids[i]] = struct{}{}
	}
}

// ClearFlagEnvironments clears the "flag_environments" edge to the FlagEnvironment entity.
func (m *EnvironmentMutation) ClearFlagEnvironments() {
	m.clearedflag_environments = true
}

// FlagEnvironmentsCleared reports if the "flag_environments" edge to the FlagEnvironment entity was cleared.
func (m *EnvironmentMutation) FlagEnvironmentsCleared() bool {
	return m.clearedflag_environments
}

// RemoveFlagEnvironmentIDs removes the "flag_environments" edge to the FlagEnvironment entity by IDs.
func (m *EnvironmentMutation) RemoveFlagEnvironmentIDs(ids ...int) {
	if m.removedflag_environments == nil {
		m.removedflag_environments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flag_environments, ids[i])
		m.removedflag_environments[ids[i]] = struct{}{}
	}
}

// RemovedFlagEnvironments returns the removed IDs of the "flag_environments" edge to the FlagEnvironment entity.
func (m *EnvironmentMutation) RemovedFlagEnvironmentsIDs() (ids []int) {
	for id := range m.removedflag_environments {
		ids = append(ids, id)
	}
	return
}

// FlagEnvironmentsIDs returns the "flag_environments" edge IDs in the mutation.
func (m *EnvironmentMutation) FlagEnvironmentsIDs() (ids []int) {
	for id := range m.flag_environments {
		ids = append(ids, id)
	}
	return
}

// ResetFlagEnvironments resets all changes to the "flag_environments" edge.
func (m *EnvironmentMutation) ResetFlagEnvironments() {
	m.flag_environments = nil
	m.clearedflag_environments = false
	m.removedflag_environments = nil
}

// Where appends a list predicates to the EnvironmentMutation builder.
func (m *EnvironmentMutation) Where(ps ...predicate.Environment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Environment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	if m._type != nil {
		fields = append(fields, environment.FieldType)
	}
	if m.sort_order != nil {
		fields = append(fields, environment.FieldSortOrder)
	}
	if m.project != nil {
		fields = append(fields, environment.FieldProjectID)
	}
	if m.created_at != nil {
		fields = append(fields, environment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, environment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldName:
		return m.Name()
	case environment.FieldType:
		return m.GetType()
	case environment.FieldSortOrder:
		return m.SortOrder()
	case environment.FieldProjectID:
		return m.ProjectID()
	case environment.FieldCreatedAt:
		return m.CreatedAt()
	case environment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldName:
		return m.OldName(ctx)
	case environment.FieldType:
		return m.OldType(ctx)
	case environment.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case environment.FieldProjectID:
		return m.OldProjectID(ctx)
	case environment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case environment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case environment.FieldType:
		v, ok := value.(environment.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case environment.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case environment.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case environment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case environment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, environment.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case environment.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldName:
		m.ResetName()
		return nil
	case environment.FieldType:
		m.ResetType()
		return nil
	case environment.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case environment.FieldProjectID:
		m.ResetProjectID()
		return nil
	case environment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case environment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, environment.EdgeProject)
	}
	if m.flag_environments != nil {
		edges = append(edges, environment.EdgeFlagEnvironments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case environment.EdgeFlagEnvironments:
		ids := make([]ent.Value, 0, len(m.flag_environments))
		for id := range m.flag_environments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflag_environments != nil {
		edges = append(edges, environment.EdgeFlagEnvironments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeFlagEnvironments:
		ids := make([]ent.Value, 0, len(m.removedflag_environments))
		for id := range m.removedflag_environments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, environment.EdgeProject)
	}
	if m.clearedflag_environments {
		edges = append(edges, environment.EdgeFlagEnvironments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeProject:
		return m.clearedproject
	case environment.EdgeFlagEnvironments:
		return m.clearedflag_environments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	case environment.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeProject:
		m.ResetProject()
		return nil
	case environment.EdgeFlagEnvironments:
		m.ResetFlagEnvironments()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// FlagMutation represents an operation that mutates the Flag nodes in the graph.
type FlagMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	description              *string
	flag_type                *flag.FlagType
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	project                  *int
	clearedproject           bool
	flag_environments        map[int]struct{}
	removedflag_environments map[int]struct{}
	clearedflag_environments bool
	done                     bool
	oldValue                 func(context.Context) (*Flag, error)
	predicates               []predicate.Flag
}

var _ ent.Mutation = (*FlagMutation)(nil)

// flagOption allows management of the mutation configuration using functional options.
type flagOption func(*FlagMutation)

// newFlagMutation creates new mutation for the Flag entity.
func newFlagMutation(c config, op Op, opts ...flagOption) *FlagMutation {
	m := &FlagMutation{
		config:        c,
		op:            op,
		typ:           TypeFlag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlagID sets the ID field of the mutation.
func withFlagID(id int) flagOption {
	return func(m *FlagMutation) {
		var (
			err   error
			once  sync.Once
			value *Flag
		)
		m.oldValue = func(ctx context.Context) (*Flag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Flag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlag sets the old Flag of the mutation.
func withFlag(node *Flag) flagOption {
	return func(m *FlagMutation) {
		m.oldValue = func(context.Context) (*Flag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Flag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FlagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FlagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Flag entity.
// If the Flag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FlagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FlagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FlagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Flag entity.
// If the Flag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FlagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[flag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FlagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[flag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FlagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, flag.FieldDescription)
}

// SetFlagType sets the "flag_type" field.
func (m *FlagMutation) SetFlagType(ft flag.FlagType) {
	m.flag_type = &ft
}

// FlagType returns the value of the "flag_type" field in the mutation.
func (m *FlagMutation) FlagType() (r flag.FlagType, exists bool) {
	v := m.flag_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFlagType returns the old "flag_type" field's value of the Flag entity.
// If the Flag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagMutation) OldFlagType(ctx context.Context) (v flag.FlagType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlagType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlagType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlagType: %w", err)
	}
	return oldValue.FlagType, nil
}

// ResetFlagType resets all changes to the "flag_type" field.
func (m *FlagMutation) ResetFlagType() {
	m.flag_type = nil
}

// SetProjectID sets the "project_id" field.
func (m *FlagMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *FlagMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Flag entity.
// If the Flag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *FlagMutation) ResetProjectID() {
	m.project = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FlagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Flag entity.
// If the Flag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Flag entity.
// If the Flag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *FlagMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[flag.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *FlagMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *FlagMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *FlagMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddFlagEnvironmentIDs adds the "flag_environments" edge to the FlagEnvironment entity by ids.
func (m *FlagMutation) AddFlagEnvironmentIDs(ids ...int) {
	if m.flag_environments == nil {
		m.flag_environments = make(map[int]struct{})
	}
	for i := range ids {
		m.flag_environments[ids[i]] = struct{}{}
	}
}

// ClearFlagEnvironments clears the "flag_environments" edge to the FlagEnvironment entity.
func (m *FlagMutation) ClearFlagEnvironments() {
	m.clearedflag_environments = true
}

// FlagEnvironmentsCleared reports if the "flag_environments" edge to the FlagEnvironment entity was cleared.
func (m *FlagMutation) FlagEnvironmentsCleared() bool {
	return m.clearedflag_environments
}

// RemoveFlagEnvironmentIDs removes the "flag_environments" edge to the FlagEnvironment entity by IDs.
func (m *FlagMutation) RemoveFlagEnvironmentIDs(ids ...int) {
	if m.removedflag_environments == nil {
		m.removedflag_environments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flag_environments, ids[i])
		m.removedflag_environments[ids[i]] = struct{}{}
	}
}

// RemovedFlagEnvironments returns the removed IDs of the "flag_environments" edge to the FlagEnvironment entity.
func (m *FlagMutation) RemovedFlagEnvironmentsIDs() (ids []int) {
	for id := range m.removedflag_environments {
		ids = append(ids, id)
	}
	return
}

// FlagEnvironmentsIDs returns the "flag_environments" edge IDs in the mutation.
func (m *FlagMutation) FlagEnvironmentsIDs() (ids []int) {
	for id := range m.flag_environments {
		ids = append(ids, id)
	}
	return
}

// ResetFlagEnvironments resets all changes to the "flag_environments" edge.
func (m *FlagMutation) ResetFlagEnvironments() {
	m.flag_environments = nil
	m.clearedflag_environments = false
	m.removedflag_environments = nil
}

// Where appends a list predicates to the FlagMutation builder.
func (m *FlagMutation) Where(ps ...predicate.Flag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FlagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FlagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Flag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FlagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FlagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Flag).
func (m *FlagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, flag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, flag.FieldDescription)
	}
	if m.flag_type != nil {
		fields = append(fields, flag.FieldFlagType)
	}
	if m.project != nil {
		fields = append(fields, flag.FieldProjectID)
	}
	if m.created_at != nil {
		fields = append(fields, flag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flag.FieldName:
		return m.Name()
	case flag.FieldDescription:
		return m.Description()
	case flag.FieldFlagType:
		return m.FlagType()
	case flag.FieldProjectID:
		return m.ProjectID()
	case flag.FieldCreatedAt:
		return m.CreatedAt()
	case flag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flag.FieldName:
		return m.OldName(ctx)
	case flag.FieldDescription:
		return m.OldDescription(ctx)
	case flag.FieldFlagType:
		return m.OldFlagType(ctx)
	case flag.FieldProjectID:
		return m.OldProjectID(ctx)
	case flag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Flag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case flag.FieldFlagType:
		v, ok := value.(flag.FlagType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlagType(v)
		return nil
	case flag.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case flag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Flag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Flag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flag.FieldDescription) {
		fields = append(fields, flag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlagMutation) ClearField(name string) error {
	switch name {
	case flag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Flag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlagMutation) ResetField(name string) error {
	switch name {
	case flag.FieldName:
		m.ResetName()
		return nil
	case flag.FieldDescription:
		m.ResetDescription()
		return nil
	case flag.FieldFlagType:
		m.ResetFlagType()
		return nil
	case flag.FieldProjectID:
		m.ResetProjectID()
		return nil
	case flag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Flag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, flag.EdgeProject)
	}
	if m.flag_environments != nil {
		edges = append(edges, flag.EdgeFlagEnvironments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flag.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case flag.EdgeFlagEnvironments:
		ids := make([]ent.Value, 0, len(m.flag_environments))
		for id := range m.flag_environments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflag_environments != nil {
		edges = append(edges, flag.EdgeFlagEnvironments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flag.EdgeFlagEnvironments:
		ids := make([]ent.Value, 0, len(m.removedflag_environments))
		for id := range m.removedflag_environments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, flag.EdgeProject)
	}
	if m.clearedflag_environments {
		edges = append(edges, flag.EdgeFlagEnvironments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlagMutation) EdgeCleared(name string) bool {
	switch name {
	case flag.EdgeProject:
		return m.clearedproject
	case flag.EdgeFlagEnvironments:
		return m.clearedflag_environments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlagMutation) ClearEdge(name string) error {
	switch name {
	case flag.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Flag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlagMutation) ResetEdge(name string) error {
	switch name {
	case flag.EdgeProject:
		m.ResetProject()
		return nil
	case flag.EdgeFlagEnvironments:
		m.ResetFlagEnvironments()
		return nil
	}
	return fmt.Errorf("unknown Flag edge %s", name)
}

// FlagEnvironmentMutation represents an operation that mutates the FlagEnvironment nodes in the graph.
type FlagEnvironmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	enabled            *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	flag               *int
	clearedflag        bool
	environment        *int
	clearedenvironment bool
	strategies         map[int]struct{}
	removedstrategies  map[int]struct{}
	clearedstrategies  bool
	done               bool
	oldValue           func(context.Context) (*FlagEnvironment, error)
	predicates         []predicate.FlagEnvironment
}

var _ ent.Mutation = (*FlagEnvironmentMutation)(nil)

// flagenvironmentOption allows management of the mutation configuration using functional options.
type flagenvironmentOption func(*FlagEnvironmentMutation)

// newFlagEnvironmentMutation creates new mutation for the FlagEnvironment entity.
func newFlagEnvironmentMutation(c config, op Op, opts ...flagenvironmentOption) *FlagEnvironmentMutation {
	m := &FlagEnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeFlagEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlagEnvironmentID sets the ID field of the mutation.
func withFlagEnvironmentID(id int) flagenvironmentOption {
	return func(m *FlagEnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *FlagEnvironment
		)
		m.oldValue = func(ctx context.Context) (*FlagEnvironment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlagEnvironment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlagEnvironment sets the old FlagEnvironment of the mutation.
func withFlagEnvironment(node *FlagEnvironment) flagenvironmentOption {
	return func(m *FlagEnvironmentMutation) {
		m.oldValue = func(context.Context) (*FlagEnvironment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlagEnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlagEnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlagEnvironmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlagEnvironmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlagEnvironment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnabled sets the "enabled" field.
func (m *FlagEnvironmentMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FlagEnvironmentMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the FlagEnvironment entity.
// If the FlagEnvironment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagEnvironmentMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FlagEnvironmentMutation) ResetEnabled() {
	m.enabled = nil
}

// SetFlagID sets the "flag_id" field.
func (m *FlagEnvironmentMutation) SetFlagID(i int) {
	m.flag = &i
}

// FlagID returns the value of the "flag_id" field in the mutation.
func (m *FlagEnvironmentMutation) FlagID() (r int, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlagID returns the old "flag_id" field's value of the FlagEnvironment entity.
// If the FlagEnvironment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagEnvironmentMutation) OldFlagID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlagID: %w", err)
	}
	return oldValue.FlagID, nil
}

// ResetFlagID resets all changes to the "flag_id" field.
func (m *FlagEnvironmentMutation) ResetFlagID() {
	m.flag = nil
}

// SetEnvironmentID sets the "environment_id" field.
func (m *FlagEnvironmentMutation) SetEnvironmentID(i int) {
	m.environment = &i
}

// EnvironmentID returns the value of the "environment_id" field in the mutation.
func (m *FlagEnvironmentMutation) EnvironmentID() (r int, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentID returns the old "environment_id" field's value of the FlagEnvironment entity.
// If the FlagEnvironment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagEnvironmentMutation) OldEnvironmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentID: %w", err)
	}
	return oldValue.EnvironmentID, nil
}

// ResetEnvironmentID resets all changes to the "environment_id" field.
func (m *FlagEnvironmentMutation) ResetEnvironmentID() {
	m.environment = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FlagEnvironmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlagEnvironmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlagEnvironment entity.
// If the FlagEnvironment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagEnvironmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlagEnvironmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlagEnvironmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlagEnvironmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlagEnvironment entity.
// If the FlagEnvironment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlagEnvironmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlagEnvironmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearFlag clears the "flag" edge to the Flag entity.
func (m *FlagEnvironmentMutation) ClearFlag() {
	m.clearedflag = true
	m.clearedFields[flagenvironment.FieldFlagID] = struct{}{}
}

// FlagCleared reports if the "flag" edge to the Flag entity was cleared.
func (m *FlagEnvironmentMutation) FlagCleared() bool {
	return m.clearedflag
}

// FlagIDs returns the "flag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlagID instead. It exists only for internal usage by the builders.
func (m *FlagEnvironmentMutation) FlagIDs() (ids []int) {
	if id := m.flag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlag resets all changes to the "flag" edge.
func (m *FlagEnvironmentMutation) ResetFlag() {
	m.flag = nil
	m.clearedflag = false
}

// ClearEnvironment clears the "environment" edge to the Environment entity.
func (m *FlagEnvironmentMutation) ClearEnvironment() {
	m.clearedenvironment = true
	m.clearedFields[flagenvironment.FieldEnvironmentID] = struct{}{}
}

// EnvironmentCleared reports if the "environment" edge to the Environment entity was cleared.
func (m *FlagEnvironmentMutation) EnvironmentCleared() bool {
	return m.clearedenvironment
}

// EnvironmentIDs returns the "environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *FlagEnvironmentMutation) EnvironmentIDs() (ids []int) {
	if id := m.environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "environment" edge.
func (m *FlagEnvironmentMutation) ResetEnvironment() {
	m.environment = nil
	m.clearedenvironment = false
}

// AddStrategyIDs adds the "strategies" edge to the Strategy entity by ids.
func (m *FlagEnvironmentMutation) AddStrategyIDs(ids ...int) {
	if m.strategies == nil {
		m.strategies = make(map[int]struct{})
	}
	for i := range ids {
		m.strategies[ids[i]] = struct{}{}
	}
}

// ClearStrategies clears the "strategies" edge to the Strategy entity.
func (m *FlagEnvironmentMutation) ClearStrategies() {
	m.clearedstrategies = true
}

// StrategiesCleared reports if the "strategies" edge to the Strategy entity was cleared.
func (m *FlagEnvironmentMutation) StrategiesCleared() bool {
	return m.clearedstrategies
}

// RemoveStrategyIDs removes the "strategies" edge to the Strategy entity by IDs.
func (m *FlagEnvironmentMutation) RemoveStrategyIDs(ids ...int) {
	if m.removedstrategies == nil {
		m.removedstrategies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.strategies, ids[i])
		m.removedstrategies[ids[i]] = struct{}{}
	}
}

// RemovedStrategies returns the removed IDs of the "strategies" edge to the Strategy entity.
func (m *FlagEnvironmentMutation) RemovedStrategiesIDs() (ids []int) {
	for id := range m.removedstrategies {
		ids = append(ids, id)
	}
	return
}

// StrategiesIDs returns the "strategies" edge IDs in the mutation.
func (m *FlagEnvironmentMutation) StrategiesIDs() (ids []int) {
	for id := range m.strategies {
		ids = append(ids, id)
	}
	return
}

// ResetStrategies resets all changes to the "strategies" edge.
func (m *FlagEnvironmentMutation) ResetStrategies() {
	m.strategies = nil
	m.clearedstrategies = false
	m.removedstrategies = nil
}

// Where appends a list predicates to the FlagEnvironmentMutation builder.
func (m *FlagEnvironmentMutation) Where(ps ...predicate.FlagEnvironment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FlagEnvironmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FlagEnvironmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FlagEnvironment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FlagEnvironmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FlagEnvironmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FlagEnvironment).
func (m *FlagEnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlagEnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.enabled != nil {
		fields = append(fields, flagenvironment.FieldEnabled)
	}
	if m.flag != nil {
		fields = append(fields, flagenvironment.FieldFlagID)
	}
	if m.environment != nil {
		fields = append(fields, flagenvironment.FieldEnvironmentID)
	}
	if m.created_at != nil {
		fields = append(fields, flagenvironment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flagenvironment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlagEnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flagenvironment.FieldEnabled:
		return m.Enabled()
	case flagenvironment.FieldFlagID:
		return m.FlagID()
	case flagenvironment.FieldEnvironmentID:
		return m.EnvironmentID()
	case flagenvironment.FieldCreatedAt:
		return m.CreatedAt()
	case flagenvironment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlagEnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flagenvironment.FieldEnabled:
		return m.OldEnabled(ctx)
	case flagenvironment.FieldFlagID:
		return m.OldFlagID(ctx)
	case flagenvironment.FieldEnvironmentID:
		return m.OldEnvironmentID(ctx)
	case flagenvironment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flagenvironment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FlagEnvironment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlagEnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flagenvironment.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case flagenvironment.FieldFlagID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlagID(v)
		return nil
	case flagenvironment.FieldEnvironmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentID(v)
		return nil
	case flagenvironment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flagenvironment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FlagEnvironment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlagEnvironmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlagEnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlagEnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlagEnvironment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlagEnvironmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlagEnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlagEnvironmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlagEnvironment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlagEnvironmentMutation) ResetField(name string) error {
	switch name {
	case flagenvironment.FieldEnabled:
		m.ResetEnabled()
		return nil
	case flagenvironment.FieldFlagID:
		m.ResetFlagID()
		return nil
	case flagenvironment.FieldEnvironmentID:
		m.ResetEnvironmentID()
		return nil
	case flagenvironment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flagenvironment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FlagEnvironment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlagEnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.flag != nil {
		edges = append(edges, flagenvironment.EdgeFlag)
	}
	if m.environment != nil {
		edges = append(edges, flagenvironment.EdgeEnvironment)
	}
	if m.strategies != nil {
		edges = append(edges, flagenvironment.EdgeStrategies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlagEnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flagenvironment.EdgeFlag:
		if id := m.flag; id != nil {
			return []ent.Value{*id}
		}
	case flagenvironment.EdgeEnvironment:
		if id := m.environment; id != nil {
			return []ent.Value{*id}
		}
	case flagenvironment.EdgeStrategies:
		ids := make([]ent.Value, 0, len(m.strategies))
		for id := range m.strategies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlagEnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstrategies != nil {
		edges = append(edges, flagenvironment.EdgeStrategies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlagEnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flagenvironment.EdgeStrategies:
		ids := make([]ent.Value, 0, len(m.removedstrategies))
		for id := range m.removedstrategies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlagEnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedflag {
		edges = append(edges, flagenvironment.EdgeFlag)
	}
	if m.clearedenvironment {
		edges = append(edges, flagenvironment.EdgeEnvironment)
	}
	if m.clearedstrategies {
		edges = append(edges, flagenvironment.EdgeStrategies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlagEnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case flagenvironment.EdgeFlag:
		return m.clearedflag
	case flagenvironment.EdgeEnvironment:
		return m.clearedenvironment
	case flagenvironment.EdgeStrategies:
		return m.clearedstrategies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlagEnvironmentMutation) ClearEdge(name string) error {
	switch name {
	case flagenvironment.EdgeFlag:
		m.ClearFlag()
		return nil
	case flagenvironment.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FlagEnvironment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlagEnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case flagenvironment.EdgeFlag:
		m.ResetFlag()
		return nil
	case flagenvironment.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case flagenvironment.EdgeStrategies:
		m.ResetStrategies()
		return nil
	}
	return fmt.Errorf("unknown FlagEnvironment edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	description         *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	environments        map[int]struct{}
	removedenvironments map[int]struct{}
	clearedenvironments bool
	flags               map[int]struct{}
	removedflags        map[int]struct{}
	clearedflags        bool
	api_tokens          map[int]struct{}
	removedapi_tokens   map[int]struct{}
	clearedapi_tokens   bool
	done                bool
	oldValue            func(context.Context) (*Project, error)
	predicates          []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddEnvironmentIDs adds the "environments" edge to the Environment entity by ids.
func (m *ProjectMutation) AddEnvironmentIDs(ids ...int) {
	if m.environments == nil {
		m.environments = make(map[int]struct{})
	}
	for i := range ids {
		m.environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "environments" edge to the Environment entity.
func (m *ProjectMutation) ClearEnvironments() {
	m.clearedenvironments = true
}

// EnvironmentsCleared reports if the "environments" edge to the Environment entity was cleared.
func (m *ProjectMutation) EnvironmentsCleared() bool {
	return m.clearedenvironments
}

// RemoveEnvironmentIDs removes the "environments" edge to the Environment entity by IDs.
func (m *ProjectMutation) RemoveEnvironmentIDs(ids ...int) {
	if m.removedenvironments == nil {
		m.removedenvironments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.environments, ids[i])
		m.removedenvironments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "environments" edge to the Environment entity.
func (m *ProjectMutation) RemovedEnvironmentsIDs() (ids []int) {
	for id := range m.removedenvironments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "environments" edge IDs in the mutation.
func (m *ProjectMutation) EnvironmentsIDs() (ids []int) {
	for id := range m.environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "environments" edge.
func (m *ProjectMutation) ResetEnvironments() {
	m.environments = nil
	m.clearedenvironments = false
	m.removedenvironments = nil
}

// AddFlagIDs adds the "flags" edge to the Flag entity by ids.
func (m *ProjectMutation) AddFlagIDs(ids ...int) {
	if m.flags == nil {
		m.flags = make(map[int]struct{})
	}
	for i := range ids {
		m.flags[ids[i]] = struct{}{}
	}
}

// ClearFlags clears the "flags" edge to the Flag entity.
func (m *ProjectMutation) ClearFlags() {
	m.clearedflags = true
}

// FlagsCleared reports if the "flags" edge to the Flag entity was cleared.
func (m *ProjectMutation) FlagsCleared() bool {
	return m.clearedflags
}

// RemoveFlagIDs removes the "flags" edge to the Flag entity by IDs.
func (m *ProjectMutation) RemoveFlagIDs(ids ...int) {
	if m.removedflags == nil {
		m.removedflags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flags, ids[i])
		m.removedflags[ids[i]] = struct{}{}
	}
}

// RemovedFlags returns the removed IDs of the "flags" edge to the Flag entity.
func (m *ProjectMutation) RemovedFlagsIDs() (ids []int) {
	for id := range m.removedflags {
		ids = append(ids, id)
	}
	return
}

// FlagsIDs returns the "flags" edge IDs in the mutation.
func (m *ProjectMutation) FlagsIDs() (ids []int) {
	for id := range m.flags {
		ids = append(ids, id)
	}
	return
}

// ResetFlags resets all changes to the "flags" edge.
func (m *ProjectMutation) ResetFlags() {
	m.flags = nil
	m.clearedflags = false
	m.removedflags = nil
}

// AddAPITokenIDs adds the "api_tokens" edge to the ApiToken entity by ids.
func (m *ProjectMutation) AddAPITokenIDs(ids ...int) {
	if m.api_tokens == nil {
		m.api_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.api_tokens[ids[i]] = struct{}{}
	}
}

// ClearAPITokens clears the "api_tokens" edge to the ApiToken entity.
func (m *ProjectMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the ApiToken entity was cleared.
func (m *ProjectMutation) APITokensCleared() bool {
	return m.clearedapi_tokens
}

// RemoveAPITokenIDs removes the "api_tokens" edge to the ApiToken entity by IDs.
func (m *ProjectMutation) RemoveAPITokenIDs(ids ...int) {
	if m.removedapi_tokens == nil {
		m.removedapi_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_tokens, ids[i])
		m.removedapi_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAPITokens returns the removed IDs of the "api_tokens" edge to the ApiToken entity.
func (m *ProjectMutation) RemovedAPITokensIDs() (ids []int) {
	for id := range m.removedapi_tokens {
		ids = append(ids, id)
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
func (m *ProjectMutation) APITokensIDs() (ids []int) {
	for id := range m.api_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *ProjectMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
	m.removedapi_tokens = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.environments != nil {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.flags != nil {
		edges = append(edges, project.EdgeFlags)
	}
	if m.api_tokens != nil {
		edges = append(edges, project.EdgeAPITokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.environments))
		for id := range m.environments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeFlags:
		ids := make([]ent.Value, 0, len(m.flags))
		for id := range m.flags {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.api_tokens))
		for id := range m.api_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedenvironments != nil {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.removedflags != nil {
		edges = append(edges, project.EdgeFlags)
	}
	if m.removedapi_tokens != nil {
		edges = append(edges, project.EdgeAPITokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removedenvironments))
		for id := range m.removedenvironments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeFlags:
		ids := make([]ent.Value, 0, len(m.removedflags))
		for id := range m.removedflags {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.removedapi_tokens))
		for id := range m.removedapi_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedenvironments {
		edges = append(edges, project.EdgeEnvironments)
	}
	if m.clearedflags {
		edges = append(edges, project.EdgeFlags)
	}
	if m.clearedapi_tokens {
		edges = append(edges, project.EdgeAPITokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeEnvironments:
		return m.clearedenvironments
	case project.EdgeFlags:
		return m.clearedflags
	case project.EdgeAPITokens:
		return m.clearedapi_tokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case project.EdgeFlags:
		m.ResetFlags()
		return nil
	case project.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// StrategyMutation represents an operation that mutates the Strategy nodes in the graph.
type StrategyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	parameters              *map[string]interface{}
	sort_order              *int
	addsort_order           *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	flag_environment        *int
	clearedflag_environment bool
	constraints             map[int]struct{}
	removedconstraints      map[int]struct{}
	clearedconstraints      bool
	done                    bool
	oldValue                func(context.Context) (*Strategy, error)
	predicates              []predicate.Strategy
}

var _ ent.Mutation = (*StrategyMutation)(nil)

// strategyOption allows management of the mutation configuration using functional options.
type strategyOption func(*StrategyMutation)

// newStrategyMutation creates new mutation for the Strategy entity.
func newStrategyMutation(c config, op Op, opts ...strategyOption) *StrategyMutation {
	m := &StrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyID sets the ID field of the mutation.
func withStrategyID(id int) strategyOption {
	return func(m *StrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *Strategy
		)
		m.oldValue = func(ctx context.Context) (*Strategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Strategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategy sets the old Strategy of the mutation.
func withStrategy(node *Strategy) strategyOption {
	return func(m *StrategyMutation) {
		m.oldValue = func(context.Context) (*Strategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Strategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StrategyMutation) ResetName() {
	m.name = nil
}

// SetParameters sets the "parameters" field.
func (m *StrategyMutation) SetParameters(value map[string]interface{}) {
	m.parameters = &value
}

// Parameters returns the value of the "parameters" field in the mutation.
func (m *StrategyMutation) Parameters() (r map[string]interface{}, exists bool) {
	v := m.parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldParameters returns the old "parameters" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldParameters(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParameters: %w", err)
	}
	return oldValue.Parameters, nil
}

// ClearParameters clears the value of the "parameters" field.
func (m *StrategyMutation) ClearParameters() {
	m.parameters = nil
	m.clearedFields[strategy.FieldParameters] = struct{}{}
}

// ParametersCleared returns if the "parameters" field was cleared in this mutation.
func (m *StrategyMutation) ParametersCleared() bool {
	_, ok := m.clearedFields[strategy.FieldParameters]
	return ok
}

// ResetParameters resets all changes to the "parameters" field.
func (m *StrategyMutation) ResetParameters() {
	m.parameters = nil
	delete(m.clearedFields, strategy.FieldParameters)
}

// SetSortOrder sets the "sort_order" field.
func (m *StrategyMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *StrategyMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *StrategyMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *StrategyMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *StrategyMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetFlagEnvironmentID sets the "flag_environment_id" field.
func (m *StrategyMutation) SetFlagEnvironmentID(i int) {
	m.flag_environment = &i
}

// FlagEnvironmentID returns the value of the "flag_environment_id" field in the mutation.
func (m *StrategyMutation) FlagEnvironmentID() (r int, exists bool) {
	v := m.flag_environment
	if v == nil {
		return
	}
	return *v, true
}

// OldFlagEnvironmentID returns the old "flag_environment_id" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldFlagEnvironmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlagEnvironmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlagEnvironmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlagEnvironmentID: %w", err)
	}
	return oldValue.FlagEnvironmentID, nil
}

// ResetFlagEnvironmentID resets all changes to the "flag_environment_id" field.
func (m *StrategyMutation) ResetFlagEnvironmentID() {
	m.flag_environment = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StrategyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StrategyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StrategyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StrategyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StrategyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StrategyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearFlagEnvironment clears the "flag_environment" edge to the FlagEnvironment entity.
func (m *StrategyMutation) ClearFlagEnvironment() {
	m.clearedflag_environment = true
	m.clearedFields[strategy.FieldFlagEnvironmentID] = struct{}{}
}

// FlagEnvironmentCleared reports if the "flag_environment" edge to the FlagEnvironment entity was cleared.
func (m *StrategyMutation) FlagEnvironmentCleared() bool {
	return m.clearedflag_environment
}

// FlagEnvironmentIDs returns the "flag_environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlagEnvironmentID instead. It exists only for internal usage by the builders.
func (m *StrategyMutation) FlagEnvironmentIDs() (ids []int) {
	if id := m.flag_environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlagEnvironment resets all changes to the "flag_environment" edge.
func (m *StrategyMutation) ResetFlagEnvironment() {
	m.flag_environment = nil
	m.clearedflag_environment = false
}

// AddConstraintIDs adds the "constraints" edge to the Constraint entity by ids.
func (m *StrategyMutation) AddConstraintIDs(ids ...int) {
	if m.constraints == nil {
		m.constraints = make(map[int]struct{})
	}
	for i := range ids {
		m.constraints[ids[i]] = struct{}{}
	}
}

// ClearConstraints clears the "constraints" edge to the Constraint entity.
func (m *StrategyMutation) ClearConstraints() {
	m.clearedconstraints = true
}

// ConstraintsCleared reports if the "constraints" edge to the Constraint entity was cleared.
func (m *StrategyMutation) ConstraintsCleared() bool {
	return m.clearedconstraints
}

// RemoveConstraintIDs removes the "constraints" edge to the Constraint entity by IDs.
func (m *StrategyMutation) RemoveConstraintIDs(ids ...int) {
	if m.removedconstraints == nil {
		m.removedconstraints = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.constraints, ids[i])
		m.removedconstraints[ids[i]] = struct{}{}
	}
}

// RemovedConstraints returns the removed IDs of the "constraints" edge to the Constraint entity.
func (m *StrategyMutation) RemovedConstraintsIDs() (ids []int) {
	for id := range m.removedconstraints {
		ids = append(ids, id)
	}
	return
}

// ConstraintsIDs returns the "constraints" edge IDs in the mutation.
func (m *StrategyMutation) ConstraintsIDs() (ids []int) {
	for id := range m.constraints {
		ids = append(ids, id)
	}
	return
}

// ResetConstraints resets all changes to the "constraints" edge.
func (m *StrategyMutation) ResetConstraints() {
	m.constraints = nil
	m.clearedconstraints = false
	m.removedconstraints = nil
}

// Where appends a list predicates to the StrategyMutation builder.
func (m *StrategyMutation) Where(ps ...predicate.Strategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Strategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Strategy).
func (m *StrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, strategy.FieldName)
	}
	if m.parameters != nil {
		fields = append(fields, strategy.FieldParameters)
	}
	if m.sort_order != nil {
		fields = append(fields, strategy.FieldSortOrder)
	}
	if m.flag_environment != nil {
		fields = append(fields, strategy.FieldFlagEnvironmentID)
	}
	if m.created_at != nil {
		fields = append(fields, strategy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, strategy.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldName:
		return m.Name()
	case strategy.FieldParameters:
		return m.Parameters()
	case strategy.FieldSortOrder:
		return m.SortOrder()
	case strategy.FieldFlagEnvironmentID:
		return m.FlagEnvironmentID()
	case strategy.FieldCreatedAt:
		return m.CreatedAt()
	case strategy.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategy.FieldName:
		return m.OldName(ctx)
	case strategy.FieldParameters:
		return m.OldParameters(ctx)
	case strategy.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case strategy.FieldFlagEnvironmentID:
		return m.OldFlagEnvironmentID(ctx)
	case strategy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case strategy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Strategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case strategy.FieldParameters:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParameters(v)
		return nil
	case strategy.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case strategy.FieldFlagEnvironmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlagEnvironmentID(v)
		return nil
	case strategy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case strategy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, strategy.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategy.FieldParameters) {
		fields = append(fields, strategy.FieldParameters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyMutation) ClearField(name string) error {
	switch name {
	case strategy.FieldParameters:
		m.ClearParameters()
		return nil
	}
	return fmt.Errorf("unknown Strategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyMutation) ResetField(name string) error {
	switch name {
	case strategy.FieldName:
		m.ResetName()
		return nil
	case strategy.FieldParameters:
		m.ResetParameters()
		return nil
	case strategy.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case strategy.FieldFlagEnvironmentID:
		m.ResetFlagEnvironmentID()
		return nil
	case strategy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case strategy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.flag_environment != nil {
		edges = append(edges, strategy.EdgeFlagEnvironment)
	}
	if m.constraints != nil {
		edges = append(edges, strategy.EdgeConstraints)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeFlagEnvironment:
		if id := m.flag_environment; id != nil {
			return []ent.Value{*id}
		}
	case strategy.EdgeConstraints:
		ids := make([]ent.Value, 0, len(m.constraints))
		for id := range m.constraints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedconstraints != nil {
		edges = append(edges, strategy.EdgeConstraints)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeConstraints:
		ids := make([]ent.Value, 0, len(m.removedconstraints))
		for id := range m.removedconstraints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedflag_environment {
		edges = append(edges, strategy.EdgeFlagEnvironment)
	}
	if m.clearedconstraints {
		edges = append(edges, strategy.EdgeConstraints)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyMutation) EdgeCleared(name string) bool {
	switch name {
	case strategy.EdgeFlagEnvironment:
		return m.clearedflag_environment
	case strategy.EdgeConstraints:
		return m.clearedconstraints
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyMutation) ClearEdge(name string) error {
	switch name {
	case strategy.EdgeFlagEnvironment:
		m.ClearFlagEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Strategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyMutation) ResetEdge(name string) error {
	switch name {
	case strategy.EdgeFlagEnvironment:
		m.ResetFlagEnvironment()
		return nil
	case strategy.EdgeConstraints:
		m.ResetConstraints()
		return nil
	}
	return fmt.Errorf("unknown Strategy edge %s", name)
}
