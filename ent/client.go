// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/felipekafuri/bandeira/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/felipekafuri/bandeira/ent/apitoken"
	"github.com/felipekafuri/bandeira/ent/constraint"
	"github.com/felipekafuri/bandeira/ent/environment"
	"github.com/felipekafuri/bandeira/ent/flag"
	"github.com/felipekafuri/bandeira/ent/flagenvironment"
	"github.com/felipekafuri/bandeira/ent/project"
	"github.com/felipekafuri/bandeira/ent/strategy"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ApiToken is the client for interacting with the ApiToken builders.
	ApiToken *ApiTokenClient
	// Constraint is the client for interacting with the Constraint builders.
	Constraint *ConstraintClient
	// Environment is the client for interacting with the Environment builders.
	Environment *EnvironmentClient
	// Flag is the client for interacting with the Flag builders.
	Flag *FlagClient
	// FlagEnvironment is the client for interacting with the FlagEnvironment builders.
	FlagEnvironment *FlagEnvironmentClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Strategy is the client for interacting with the Strategy builders.
	Strategy *StrategyClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ApiToken = NewApiTokenClient(c.config)
	c.Constraint = NewConstraintClient(c.config)
	c.Environment = NewEnvironmentClient(c.config)
	c.Flag = NewFlagClient(c.config)
	c.FlagEnvironment = NewFlagEnvironmentClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Strategy = NewStrategyClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		ApiToken:        NewApiTokenClient(cfg),
		Constraint:      NewConstraintClient(cfg),
		Environment:     NewEnvironmentClient(cfg),
		Flag:            NewFlagClient(cfg),
		FlagEnvironment: NewFlagEnvironmentClient(cfg),
		Project:         NewProjectClient(cfg),
		Strategy:        NewStrategyClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		ApiToken:        NewApiTokenClient(cfg),
		Constraint:      NewConstraintClient(cfg),
		Environment:     NewEnvironmentClient(cfg),
		Flag:            NewFlagClient(cfg),
		FlagEnvironment: NewFlagEnvironmentClient(cfg),
		Project:         NewProjectClient(cfg),
		Strategy:        NewStrategyClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ApiToken.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ApiToken, c.Constraint, c.Environment, c.Flag, c.FlagEnvironment, c.Project,
		c.Strategy,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ApiToken, c.Constraint, c.Environment, c.Flag, c.FlagEnvironment, c.Project,
		c.Strategy,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ApiTokenMutation:
		return c.ApiToken.mutate(ctx, m)
	case *ConstraintMutation:
		return c.Constraint.mutate(ctx, m)
	case *EnvironmentMutation:
		return c.Environment.mutate(ctx, m)
	case *FlagMutation:
		return c.Flag.mutate(ctx, m)
	case *FlagEnvironmentMutation:
		return c.FlagEnvironment.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *StrategyMutation:
		return c.Strategy.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ApiTokenClient is a client for the ApiToken schema.
type ApiTokenClient struct {
	config
}

// NewApiTokenClient returns a client for the ApiToken from the given config.
func NewApiTokenClient(c config) *ApiTokenClient {
	return &ApiTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apitoken.Hooks(f(g(h())))`.
func (c *ApiTokenClient) Use(hooks ...Hook) {
	c.hooks.ApiToken = append(c.hooks.ApiToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apitoken.Intercept(f(g(h())))`.
func (c *ApiTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApiToken = append(c.inters.ApiToken, interceptors...)
}

// Create returns a builder for creating a ApiToken entity.
func (c *ApiTokenClient) Create() *ApiTokenCreate {
	mutation := newApiTokenMutation(c.config, OpCreate)
	return &ApiTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApiToken entities.
func (c *ApiTokenClient) CreateBulk(builders ...*ApiTokenCreate) *ApiTokenCreateBulk {
	return &ApiTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApiTokenClient) MapCreateBulk(slice any, setFunc func(*ApiTokenCreate, int)) *ApiTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApiTokenCreateBulk{err: fmt.Errorf("calling to ApiTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApiTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApiTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApiToken.
func (c *ApiTokenClient) Update() *ApiTokenUpdate {
	mutation := newApiTokenMutation(c.config, OpUpdate)
	return &ApiTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApiTokenClient) UpdateOne(_m *ApiToken) *ApiTokenUpdateOne {
	mutation := newApiTokenMutation(c.config, OpUpdateOne, withApiToken(_m))
	return &ApiTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApiTokenClient) UpdateOneID(id int) *ApiTokenUpdateOne {
	mutation := newApiTokenMutation(c.config, OpUpdateOne, withApiTokenID(id))
	return &ApiTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApiToken.
func (c *ApiTokenClient) Delete() *ApiTokenDelete {
	mutation := newApiTokenMutation(c.config, OpDelete)
	return &ApiTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApiTokenClient) DeleteOne(_m *ApiToken) *ApiTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApiTokenClient) DeleteOneID(id int) *ApiTokenDeleteOne {
	builder := c.Delete().Where(apitoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApiTokenDeleteOne{builder}
}

// Query returns a query builder for ApiToken.
func (c *ApiTokenClient) Query() *ApiTokenQuery {
	return &ApiTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApiToken},
		inters: c.Interceptors(),
	}
}

// Get returns a ApiToken entity by its id.
func (c *ApiTokenClient) Get(ctx context.Context, id int) (*ApiToken, error) {
	return c.Query().Where(apitoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApiTokenClient) GetX(ctx context.Context, id int) *ApiToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a ApiToken.
func (c *ApiTokenClient) QueryProject(_m *ApiToken) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apitoken.Table, apitoken.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apitoken.ProjectTable, apitoken.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ApiTokenClient) Hooks() []Hook {
	return c.hooks.ApiToken
}

// Interceptors returns the client interceptors.
func (c *ApiTokenClient) Interceptors() []Interceptor {
	return c.inters.ApiToken
}

func (c *ApiTokenClient) mutate(ctx context.Context, m *ApiTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApiTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApiTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApiTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApiTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ApiToken mutation op: %q", m.Op())
	}
}

// ConstraintClient is a client for the Constraint schema.
type ConstraintClient struct {
	config
}

// NewConstraintClient returns a client for the Constraint from the given config.
func NewConstraintClient(c config) *ConstraintClient {
	return &ConstraintClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `constraint.Hooks(f(g(h())))`.
func (c *ConstraintClient) Use(hooks ...Hook) {
	c.hooks.Constraint = append(c.hooks.Constraint, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `constraint.Intercept(f(g(h())))`.
func (c *ConstraintClient) Intercept(interceptors ...Interceptor) {
	c.inters.Constraint = append(c.inters.Constraint, interceptors...)
}

// Create returns a builder for creating a Constraint entity.
func (c *ConstraintClient) Create() *ConstraintCreate {
	mutation := newConstraintMutation(c.config, OpCreate)
	return &ConstraintCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Constraint entities.
func (c *ConstraintClient) CreateBulk(builders ...*ConstraintCreate) *ConstraintCreateBulk {
	return &ConstraintCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConstraintClient) MapCreateBulk(slice any, setFunc func(*ConstraintCreate, int)) *ConstraintCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConstraintCreateBulk{err: fmt.Errorf("calling to ConstraintClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConstraintCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConstraintCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Constraint.
func (c *ConstraintClient) Update() *ConstraintUpdate {
	mutation := newConstraintMutation(c.config, OpUpdate)
	return &ConstraintUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConstraintClient) UpdateOne(_m *Constraint) *ConstraintUpdateOne {
	mutation := newConstraintMutation(c.config, OpUpdateOne, withConstraint(_m))
	return &ConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConstraintClient) UpdateOneID(id int) *ConstraintUpdateOne {
	mutation := newConstraintMutation(c.config, OpUpdateOne, withConstraintID(id))
	return &ConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Constraint.
func (c *ConstraintClient) Delete() *ConstraintDelete {
	mutation := newConstraintMutation(c.config, OpDelete)
	return &ConstraintDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConstraintClient) DeleteOne(_m *Constraint) *ConstraintDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConstraintClient) DeleteOneID(id int) *ConstraintDeleteOne {
	builder := c.Delete().Where(constraint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConstraintDeleteOne{builder}
}

// Query returns a query builder for Constraint.
func (c *ConstraintClient) Query() *ConstraintQuery {
	return &ConstraintQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConstraint},
		inters: c.Interceptors(),
	}
}

// Get returns a Constraint entity by its id.
func (c *ConstraintClient) Get(ctx context.Context, id int) (*Constraint, error) {
	return c.Query().Where(constraint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConstraintClient) GetX(ctx context.Context, id int) *Constraint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStrategy queries the strategy edge of a Constraint.
func (c *ConstraintClient) QueryStrategy(_m *Constraint) *StrategyQuery {
	query := (&StrategyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(constraint.Table, constraint.FieldID, id),
			sqlgraph.To(strategy.Table, strategy.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, constraint.StrategyTable, constraint.StrategyColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConstraintClient) Hooks() []Hook {
	return c.hooks.Constraint
}

// Interceptors returns the client interceptors.
func (c *ConstraintClient) Interceptors() []Interceptor {
	return c.inters.Constraint
}

func (c *ConstraintClient) mutate(ctx context.Context, m *ConstraintMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConstraintCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConstraintUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConstraintUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConstraintDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Constraint mutation op: %q", m.Op())
	}
}

// EnvironmentClient is a client for the Environment schema.
type EnvironmentClient struct {
	config
}

// NewEnvironmentClient returns a client for the Environment from the given config.
func NewEnvironmentClient(c config) *EnvironmentClient {
	return &EnvironmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `environment.Hooks(f(g(h())))`.
func (c *EnvironmentClient) Use(hooks ...Hook) {
	c.hooks.Environment = append(c.hooks.Environment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `environment.Intercept(f(g(h())))`.
func (c *EnvironmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Environment = append(c.inters.Environment, interceptors...)
}

// Create returns a builder for creating a Environment entity.
func (c *EnvironmentClient) Create() *EnvironmentCreate {
	mutation := newEnvironmentMutation(c.config, OpCreate)
	return &EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Environment entities.
func (c *EnvironmentClient) CreateBulk(builders ...*EnvironmentCreate) *EnvironmentCreateBulk {
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvironmentClient) MapCreateBulk(slice any, setFunc func(*EnvironmentCreate, int)) *EnvironmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvironmentCreateBulk{err: fmt.Errorf("calling to EnvironmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvironmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Environment.
func (c *EnvironmentClient) Update() *EnvironmentUpdate {
	mutation := newEnvironmentMutation(c.config, OpUpdate)
	return &EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvironmentClient) UpdateOne(_m *Environment) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironment(_m))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvironmentClient) UpdateOneID(id int) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironmentID(id))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Environment.
func (c *EnvironmentClient) Delete() *EnvironmentDelete {
	mutation := newEnvironmentMutation(c.config, OpDelete)
	return &EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvironmentClient) DeleteOne(_m *Environment) *EnvironmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvironmentClient) DeleteOneID(id int) *EnvironmentDeleteOne {
	builder := c.Delete().Where(environment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvironmentDeleteOne{builder}
}

// Query returns a query builder for Environment.
func (c *EnvironmentClient) Query() *EnvironmentQuery {
	return &EnvironmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvironment},
		inters: c.Interceptors(),
	}
}

// Get returns a Environment entity by its id.
func (c *EnvironmentClient) Get(ctx context.Context, id int) (*Environment, error) {
	return c.Query().Where(environment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvironmentClient) GetX(ctx context.Context, id int) *Environment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Environment.
func (c *EnvironmentClient) QueryProject(_m *Environment) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, environment.ProjectTable, environment.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFlagEnvironments queries the flag_environments edge of a Environment.
func (c *EnvironmentClient) QueryFlagEnvironments(_m *Environment) *FlagEnvironmentQuery {
	query := (&FlagEnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(flagenvironment.Table, flagenvironment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.FlagEnvironmentsTable, environment.FlagEnvironmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvironmentClient) Hooks() []Hook {
	return c.hooks.Environment
}

// Interceptors returns the client interceptors.
func (c *EnvironmentClient) Interceptors() []Interceptor {
	return c.inters.Environment
}

func (c *EnvironmentClient) mutate(ctx context.Context, m *EnvironmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Environment mutation op: %q", m.Op())
	}
}

// FlagClient is a client for the Flag schema.
type FlagClient struct {
	config
}

// NewFlagClient returns a client for the Flag from the given config.
func NewFlagClient(c config) *FlagClient {
	return &FlagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `flag.Hooks(f(g(h())))`.
func (c *FlagClient) Use(hooks ...Hook) {
	c.hooks.Flag = append(c.hooks.Flag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `flag.Intercept(f(g(h())))`.
func (c *FlagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Flag = append(c.inters.Flag, interceptors...)
}

// Create returns a builder for creating a Flag entity.
func (c *FlagClient) Create() *FlagCreate {
	mutation := newFlagMutation(c.config, OpCreate)
	return &FlagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Flag entities.
func (c *FlagClient) CreateBulk(builders ...*FlagCreate) *FlagCreateBulk {
	return &FlagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FlagClient) MapCreateBulk(slice any, setFunc func(*FlagCreate, int)) *FlagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FlagCreateBulk{err: fmt.Errorf("calling to FlagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FlagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FlagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Flag.
func (c *FlagClient) Update() *FlagUpdate {
	mutation := newFlagMutation(c.config, OpUpdate)
	return &FlagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FlagClient) UpdateOne(_m *Flag) *FlagUpdateOne {
	mutation := newFlagMutation(c.config, OpUpdateOne, withFlag(_m))
	return &FlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FlagClient) UpdateOneID(id int) *FlagUpdateOne {
	mutation := newFlagMutation(c.config, OpUpdateOne, withFlagID(id))
	return &FlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Flag.
func (c *FlagClient) Delete() *FlagDelete {
	mutation := newFlagMutation(c.config, OpDelete)
	return &FlagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FlagClient) DeleteOne(_m *Flag) *FlagDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FlagClient) DeleteOneID(id int) *FlagDeleteOne {
	builder := c.Delete().Where(flag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FlagDeleteOne{builder}
}

// Query returns a query builder for Flag.
func (c *FlagClient) Query() *FlagQuery {
	return &FlagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFlag},
		inters: c.Interceptors(),
	}
}

// Get returns a Flag entity by its id.
func (c *FlagClient) Get(ctx context.Context, id int) (*Flag, error) {
	return c.Query().Where(flag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FlagClient) GetX(ctx context.Context, id int) *Flag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Flag.
func (c *FlagClient) QueryProject(_m *Flag) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flag.Table, flag.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, flag.ProjectTable, flag.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFlagEnvironments queries the flag_environments edge of a Flag.
func (c *FlagClient) QueryFlagEnvironments(_m *Flag) *FlagEnvironmentQuery {
	query := (&FlagEnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flag.Table, flag.FieldID, id),
			sqlgraph.To(flagenvironment.Table, flagenvironment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, flag.FlagEnvironmentsTable, flag.FlagEnvironmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FlagClient) Hooks() []Hook {
	return c.hooks.Flag
}

// Interceptors returns the client interceptors.
func (c *FlagClient) Interceptors() []Interceptor {
	return c.inters.Flag
}

func (c *FlagClient) mutate(ctx context.Context, m *FlagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FlagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FlagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FlagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Flag mutation op: %q", m.Op())
	}
}

// FlagEnvironmentClient is a client for the FlagEnvironment schema.
type FlagEnvironmentClient struct {
	config
}

// NewFlagEnvironmentClient returns a client for the FlagEnvironment from the given config.
func NewFlagEnvironmentClient(c config) *FlagEnvironmentClient {
	return &FlagEnvironmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `flagenvironment.Hooks(f(g(h())))`.
func (c *FlagEnvironmentClient) Use(hooks ...Hook) {
	c.hooks.FlagEnvironment = append(c.hooks.FlagEnvironment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `flagenvironment.Intercept(f(g(h())))`.
func (c *FlagEnvironmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.FlagEnvironment = append(c.inters.FlagEnvironment, interceptors...)
}

// Create returns a builder for creating a FlagEnvironment entity.
func (c *FlagEnvironmentClient) Create() *FlagEnvironmentCreate {
	mutation := newFlagEnvironmentMutation(c.config, OpCreate)
	return &FlagEnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FlagEnvironment entities.
func (c *FlagEnvironmentClient) CreateBulk(builders ...*FlagEnvironmentCreate) *FlagEnvironmentCreateBulk {
	return &FlagEnvironmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FlagEnvironmentClient) MapCreateBulk(slice any, setFunc func(*FlagEnvironmentCreate, int)) *FlagEnvironmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FlagEnvironmentCreateBulk{err: fmt.Errorf("calling to FlagEnvironmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FlagEnvironmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FlagEnvironmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FlagEnvironment.
func (c *FlagEnvironmentClient) Update() *FlagEnvironmentUpdate {
	mutation := newFlagEnvironmentMutation(c.config, OpUpdate)
	return &FlagEnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FlagEnvironmentClient) UpdateOne(_m *FlagEnvironment) *FlagEnvironmentUpdateOne {
	mutation := newFlagEnvironmentMutation(c.config, OpUpdateOne, withFlagEnvironment(_m))
	return &FlagEnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FlagEnvironmentClient) UpdateOneID(id int) *FlagEnvironmentUpdateOne {
	mutation := newFlagEnvironmentMutation(c.config, OpUpdateOne, withFlagEnvironmentID(id))
	return &FlagEnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FlagEnvironment.
func (c *FlagEnvironmentClient) Delete() *FlagEnvironmentDelete {
	mutation := newFlagEnvironmentMutation(c.config, OpDelete)
	return &FlagEnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FlagEnvironmentClient) DeleteOne(_m *FlagEnvironment) *FlagEnvironmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FlagEnvironmentClient) DeleteOneID(id int) *FlagEnvironmentDeleteOne {
	builder := c.Delete().Where(flagenvironment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FlagEnvironmentDeleteOne{builder}
}

// Query returns a query builder for FlagEnvironment.
func (c *FlagEnvironmentClient) Query() *FlagEnvironmentQuery {
	return &FlagEnvironmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFlagEnvironment},
		inters: c.Interceptors(),
	}
}

// Get returns a FlagEnvironment entity by its id.
func (c *FlagEnvironmentClient) Get(ctx context.Context, id int) (*FlagEnvironment, error) {
	return c.Query().Where(flagenvironment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FlagEnvironmentClient) GetX(ctx context.Context, id int) *FlagEnvironment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFlag queries the flag edge of a FlagEnvironment.
func (c *FlagEnvironmentClient) QueryFlag(_m *FlagEnvironment) *FlagQuery {
	query := (&FlagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flagenvironment.Table, flagenvironment.FieldID, id),
			sqlgraph.To(flag.Table, flag.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, flagenvironment.FlagTable, flagenvironment.FlagColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the environment edge of a FlagEnvironment.
func (c *FlagEnvironmentClient) QueryEnvironment(_m *FlagEnvironment) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flagenvironment.Table, flagenvironment.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, flagenvironment.EnvironmentTable, flagenvironment.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStrategies queries the strategies edge of a FlagEnvironment.
func (c *FlagEnvironmentClient) QueryStrategies(_m *FlagEnvironment) *StrategyQuery {
	query := (&StrategyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(flagenvironment.Table, flagenvironment.FieldID, id),
			sqlgraph.To(strategy.Table, strategy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, flagenvironment.StrategiesTable, flagenvironment.StrategiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FlagEnvironmentClient) Hooks() []Hook {
	return c.hooks.FlagEnvironment
}

// Interceptors returns the client interceptors.
func (c *FlagEnvironmentClient) Interceptors() []Interceptor {
	return c.inters.FlagEnvironment
}

func (c *FlagEnvironmentClient) mutate(ctx context.Context, m *FlagEnvironmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FlagEnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FlagEnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FlagEnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FlagEnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FlagEnvironment mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(_m *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(_m))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(_m *Project) *ProjectDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironments queries the environments edge of a Project.
func (c *ProjectClient) QueryEnvironments(_m *Project) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.EnvironmentsTable, project.EnvironmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFlags queries the flags edge of a Project.
func (c *ProjectClient) QueryFlags(_m *Project) *FlagQuery {
	query := (&FlagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(flag.Table, flag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.FlagsTable, project.FlagsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPITokens queries the api_tokens edge of a Project.
func (c *ProjectClient) QueryAPITokens(_m *Project) *ApiTokenQuery {
	query := (&ApiTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(apitoken.Table, apitoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, project.APITokensTable, project.APITokensColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// StrategyClient is a client for the Strategy schema.
type StrategyClient struct {
	config
}

// NewStrategyClient returns a client for the Strategy from the given config.
func NewStrategyClient(c config) *StrategyClient {
	return &StrategyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `strategy.Hooks(f(g(h())))`.
func (c *StrategyClient) Use(hooks ...Hook) {
	c.hooks.Strategy = append(c.hooks.Strategy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `strategy.Intercept(f(g(h())))`.
func (c *StrategyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Strategy = append(c.inters.Strategy, interceptors...)
}

// Create returns a builder for creating a Strategy entity.
func (c *StrategyClient) Create() *StrategyCreate {
	mutation := newStrategyMutation(c.config, OpCreate)
	return &StrategyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Strategy entities.
func (c *StrategyClient) CreateBulk(builders ...*StrategyCreate) *StrategyCreateBulk {
	return &StrategyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StrategyClient) MapCreateBulk(slice any, setFunc func(*StrategyCreate, int)) *StrategyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StrategyCreateBulk{err: fmt.Errorf("calling to StrategyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StrategyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StrategyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Strategy.
func (c *StrategyClient) Update() *StrategyUpdate {
	mutation := newStrategyMutation(c.config, OpUpdate)
	return &StrategyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StrategyClient) UpdateOne(_m *Strategy) *StrategyUpdateOne {
	mutation := newStrategyMutation(c.config, OpUpdateOne, withStrategy(_m))
	return &StrategyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StrategyClient) UpdateOneID(id int) *StrategyUpdateOne {
	mutation := newStrategyMutation(c.config, OpUpdateOne, withStrategyID(id))
	return &StrategyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Strategy.
func (c *StrategyClient) Delete() *StrategyDelete {
	mutation := newStrategyMutation(c.config, OpDelete)
	return &StrategyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StrategyClient) DeleteOne(_m *Strategy) *StrategyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StrategyClient) DeleteOneID(id int) *StrategyDeleteOne {
	builder := c.Delete().Where(strategy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StrategyDeleteOne{builder}
}

// Query returns a query builder for Strategy.
func (c *StrategyClient) Query() *StrategyQuery {
	return &StrategyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStrategy},
		inters: c.Interceptors(),
	}
}

// Get returns a Strategy entity by its id.
func (c *StrategyClient) Get(ctx context.Context, id int) (*Strategy, error) {
	return c.Query().Where(strategy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StrategyClient) GetX(ctx context.Context, id int) *Strategy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFlagEnvironment queries the flag_environment edge of a Strategy.
func (c *StrategyClient) QueryFlagEnvironment(_m *Strategy) *FlagEnvironmentQuery {
	query := (&FlagEnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(strategy.Table, strategy.FieldID, id),
			sqlgraph.To(flagenvironment.Table, flagenvironment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, strategy.FlagEnvironmentTable, strategy.FlagEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConstraints queries the constraints edge of a Strategy.
func (c *StrategyClient) QueryConstraints(_m *Strategy) *ConstraintQuery {
	query := (&ConstraintClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(strategy.Table, strategy.FieldID, id),
			sqlgraph.To(constraint.Table, constraint.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, strategy.ConstraintsTable, strategy.ConstraintsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StrategyClient) Hooks() []Hook {
	return c.hooks.Strategy
}

// Interceptors returns the client interceptors.
func (c *StrategyClient) Interceptors() []Interceptor {
	return c.inters.Strategy
}

func (c *StrategyClient) mutate(ctx context.Context, m *StrategyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StrategyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StrategyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StrategyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StrategyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Strategy mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ApiToken, Constraint, Environment, Flag, FlagEnvironment, Project,
		Strategy []ent.Hook
	}
	inters struct {
		ApiToken, Constraint, Environment, Flag, FlagEnvironment, Project,
		Strategy []ent.Interceptor
	}
)
