// Code generated by ent, DO NOT EDIT.
package admin

import (
	"fmt"
	"net/url"
	"strconv"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/labstack/echo/v4"

	"github.com/felipekafuri/bandeira/ent"
	"github.com/felipekafuri/bandeira/ent/apitoken"
	"github.com/felipekafuri/bandeira/ent/constraint"
	"github.com/felipekafuri/bandeira/ent/environment"
	"github.com/felipekafuri/bandeira/ent/flag"
	"github.com/felipekafuri/bandeira/ent/flagenvironment"
	"github.com/felipekafuri/bandeira/ent/project"
	"github.com/felipekafuri/bandeira/ent/strategy"
	"github.com/felipekafuri/bandeira/ent/user"
)

const dateTimeFormat = "2006-01-02T15:04:05"
const dateTimeFormatNoSeconds = "2006-01-02T15:04"

type Handler struct {
	client *ent.Client
	Config HandlerConfig
}

func NewHandler(client *ent.Client, cfg HandlerConfig) *Handler {
	return &Handler{
		client: client,
		Config: cfg,
	}
}

func (h *Handler) Create(ctx echo.Context, entityType string) error {
	switch entityType {
	case "ApiToken":
		return h.ApiTokenCreate(ctx)
	case "Constraint":
		return h.ConstraintCreate(ctx)
	case "Environment":
		return h.EnvironmentCreate(ctx)
	case "Flag":
		return h.FlagCreate(ctx)
	case "FlagEnvironment":
		return h.FlagEnvironmentCreate(ctx)
	case "Project":
		return h.ProjectCreate(ctx)
	case "Strategy":
		return h.StrategyCreate(ctx)
	case "User":
		return h.UserCreate(ctx)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Get(ctx echo.Context, entityType string, id int) (url.Values, error) {
	switch entityType {
	case "ApiToken":
		return h.ApiTokenGet(ctx, id)
	case "Constraint":
		return h.ConstraintGet(ctx, id)
	case "Environment":
		return h.EnvironmentGet(ctx, id)
	case "Flag":
		return h.FlagGet(ctx, id)
	case "FlagEnvironment":
		return h.FlagEnvironmentGet(ctx, id)
	case "Project":
		return h.ProjectGet(ctx, id)
	case "Strategy":
		return h.StrategyGet(ctx, id)
	case "User":
		return h.UserGet(ctx, id)
	default:
		return nil, fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Delete(ctx echo.Context, entityType string, id int) error {
	switch entityType {
	case "ApiToken":
		return h.ApiTokenDelete(ctx, id)
	case "Constraint":
		return h.ConstraintDelete(ctx, id)
	case "Environment":
		return h.EnvironmentDelete(ctx, id)
	case "Flag":
		return h.FlagDelete(ctx, id)
	case "FlagEnvironment":
		return h.FlagEnvironmentDelete(ctx, id)
	case "Project":
		return h.ProjectDelete(ctx, id)
	case "Strategy":
		return h.StrategyDelete(ctx, id)
	case "User":
		return h.UserDelete(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Update(ctx echo.Context, entityType string, id int) error {
	switch entityType {
	case "ApiToken":
		return h.ApiTokenUpdate(ctx, id)
	case "Constraint":
		return h.ConstraintUpdate(ctx, id)
	case "Environment":
		return h.EnvironmentUpdate(ctx, id)
	case "Flag":
		return h.FlagUpdate(ctx, id)
	case "FlagEnvironment":
		return h.FlagEnvironmentUpdate(ctx, id)
	case "Project":
		return h.ProjectUpdate(ctx, id)
	case "Strategy":
		return h.StrategyUpdate(ctx, id)
	case "User":
		return h.UserUpdate(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) List(ctx echo.Context, entityType string) (*EntityList, error) {
	switch entityType {
	case "ApiToken":
		return h.ApiTokenList(ctx)
	case "Constraint":
		return h.ConstraintList(ctx)
	case "Environment":
		return h.EnvironmentList(ctx)
	case "Flag":
		return h.FlagList(ctx)
	case "FlagEnvironment":
		return h.FlagEnvironmentList(ctx)
	case "Project":
		return h.ProjectList(ctx)
	case "Strategy":
		return h.StrategyList(ctx)
	case "User":
		return h.UserList(ctx)
	default:
		return nil, fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) ApiTokenCreate(ctx echo.Context) error {
	var payload ApiToken
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.ApiToken.Create()
	if payload.Secret != nil {
		op.SetSecret(*payload.Secret)
	}
	if payload.PlainToken != nil {
		op.SetPlainToken(*payload.PlainToken)
	}
	op.SetName(payload.Name)
	op.SetTokenType(payload.TokenType)
	if payload.Environment != nil {
		op.SetEnvironment(*payload.Environment)
	}
	op.SetProjectID(payload.ProjectID)
	if payload.CreatedBy != nil {
		op.SetCreatedBy(*payload.CreatedBy)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) ApiTokenUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.ApiToken.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload ApiToken
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	if payload.Secret != nil {
		op.SetSecret(*payload.Secret)
	}
	if payload.PlainToken == nil {
		var empty string
		op.SetPlainToken(empty)
	} else {
		op.SetPlainToken(*payload.PlainToken)
	}
	op.SetName(payload.Name)
	op.SetTokenType(payload.TokenType)
	if payload.Environment == nil {
		op.ClearEnvironment()
	} else {
		op.SetEnvironment(*payload.Environment)
	}
	op.SetProjectID(payload.ProjectID)
	op.SetNillableCreatedBy(payload.CreatedBy)
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) ApiTokenDelete(ctx echo.Context, id int) error {
	return h.client.ApiToken.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) ApiTokenList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.ApiToken.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(apitoken.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Plain token",
			"Name",
			"Token type",
			"Environment",
			"Project ID",
			"Created by",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].PlainToken,
				res[i].Name,
				fmt.Sprint(res[i].TokenType),
				res[i].Environment,
				fmt.Sprint(res[i].ProjectID),
				fmt.Sprint(res[i].CreatedBy),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) ApiTokenGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.ApiToken.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("plain_token", entity.PlainToken)
	v.Set("name", entity.Name)
	v.Set("token_type", fmt.Sprint(entity.TokenType))
	v.Set("environment", entity.Environment)
	v.Set("project_id", fmt.Sprint(entity.ProjectID))
	v.Set("created_by", fmt.Sprint(entity.CreatedBy))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) ConstraintCreate(ctx echo.Context) error {
	var payload Constraint
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Constraint.Create()
	op.SetContextName(payload.ContextName)
	op.SetOperator(payload.Operator)
	op.SetValues(payload.Values)
	op.SetInverted(payload.Inverted)
	op.SetCaseInsensitive(payload.CaseInsensitive)
	op.SetStrategyID(payload.StrategyID)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) ConstraintUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Constraint.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Constraint
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetContextName(payload.ContextName)
	op.SetOperator(payload.Operator)
	op.SetValues(payload.Values)
	op.SetInverted(payload.Inverted)
	op.SetCaseInsensitive(payload.CaseInsensitive)
	op.SetStrategyID(payload.StrategyID)
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) ConstraintDelete(ctx echo.Context, id int) error {
	return h.client.Constraint.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) ConstraintList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Constraint.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(constraint.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Context name",
			"Operator",
			"Values",
			"Inverted",
			"Case insensitive",
			"Strategy ID",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].ContextName,
				fmt.Sprint(res[i].Operator),
				fmt.Sprint(res[i].Values),
				fmt.Sprint(res[i].Inverted),
				fmt.Sprint(res[i].CaseInsensitive),
				fmt.Sprint(res[i].StrategyID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) ConstraintGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Constraint.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("context_name", entity.ContextName)
	v.Set("operator", fmt.Sprint(entity.Operator))
	v.Set("values", fmt.Sprint(entity.Values))
	v.Set("inverted", fmt.Sprint(entity.Inverted))
	v.Set("case_insensitive", fmt.Sprint(entity.CaseInsensitive))
	v.Set("strategy_id", fmt.Sprint(entity.StrategyID))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) EnvironmentCreate(ctx echo.Context) error {
	var payload Environment
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Environment.Create()
	op.SetName(payload.Name)
	op.SetType(payload.Type)
	if payload.SortOrder != nil {
		op.SetSortOrder(*payload.SortOrder)
	}
	op.SetProjectID(payload.ProjectID)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) EnvironmentUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Environment.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Environment
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetName(payload.Name)
	op.SetType(payload.Type)
	if payload.SortOrder == nil {
		var empty int
		op.SetSortOrder(empty)
	} else {
		op.SetSortOrder(*payload.SortOrder)
	}
	op.SetProjectID(payload.ProjectID)
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) EnvironmentDelete(ctx echo.Context, id int) error {
	return h.client.Environment.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) EnvironmentList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Environment.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(environment.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Name",
			"Type",
			"Sort order",
			"Project ID",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Name,
				fmt.Sprint(res[i].Type),
				fmt.Sprint(res[i].SortOrder),
				fmt.Sprint(res[i].ProjectID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) EnvironmentGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Environment.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("name", entity.Name)
	v.Set("type", fmt.Sprint(entity.Type))
	v.Set("sort_order", fmt.Sprint(entity.SortOrder))
	v.Set("project_id", fmt.Sprint(entity.ProjectID))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) FlagCreate(ctx echo.Context) error {
	var payload Flag
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Flag.Create()
	op.SetName(payload.Name)
	if payload.Description != nil {
		op.SetDescription(*payload.Description)
	}
	op.SetFlagType(payload.FlagType)
	op.SetProjectID(payload.ProjectID)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) FlagUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Flag.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Flag
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetName(payload.Name)
	if payload.Description == nil {
		op.ClearDescription()
	} else {
		op.SetDescription(*payload.Description)
	}
	op.SetFlagType(payload.FlagType)
	op.SetProjectID(payload.ProjectID)
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) FlagDelete(ctx echo.Context, id int) error {
	return h.client.Flag.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) FlagList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Flag.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(flag.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Name",
			"Description",
			"Flag type",
			"Project ID",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Name,
				res[i].Description,
				fmt.Sprint(res[i].FlagType),
				fmt.Sprint(res[i].ProjectID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) FlagGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Flag.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("name", entity.Name)
	v.Set("description", entity.Description)
	v.Set("flag_type", fmt.Sprint(entity.FlagType))
	v.Set("project_id", fmt.Sprint(entity.ProjectID))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) FlagEnvironmentCreate(ctx echo.Context) error {
	var payload FlagEnvironment
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.FlagEnvironment.Create()
	op.SetEnabled(payload.Enabled)
	op.SetFlagID(payload.FlagID)
	op.SetEnvironmentID(payload.EnvironmentID)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) FlagEnvironmentUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.FlagEnvironment.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload FlagEnvironment
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetEnabled(payload.Enabled)
	op.SetFlagID(payload.FlagID)
	op.SetEnvironmentID(payload.EnvironmentID)
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) FlagEnvironmentDelete(ctx echo.Context, id int) error {
	return h.client.FlagEnvironment.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) FlagEnvironmentList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.FlagEnvironment.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(flagenvironment.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Enabled",
			"Flag ID",
			"Environment ID",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				fmt.Sprint(res[i].Enabled),
				fmt.Sprint(res[i].FlagID),
				fmt.Sprint(res[i].EnvironmentID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) FlagEnvironmentGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.FlagEnvironment.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("enabled", fmt.Sprint(entity.Enabled))
	v.Set("flag_id", fmt.Sprint(entity.FlagID))
	v.Set("environment_id", fmt.Sprint(entity.EnvironmentID))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) ProjectCreate(ctx echo.Context) error {
	var payload Project
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Project.Create()
	op.SetName(payload.Name)
	if payload.Description != nil {
		op.SetDescription(*payload.Description)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) ProjectUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Project.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Project
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetName(payload.Name)
	if payload.Description == nil {
		op.ClearDescription()
	} else {
		op.SetDescription(*payload.Description)
	}
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) ProjectDelete(ctx echo.Context, id int) error {
	return h.client.Project.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) ProjectList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Project.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(project.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Name",
			"Description",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Name,
				res[i].Description,
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) ProjectGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Project.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("name", entity.Name)
	v.Set("description", entity.Description)
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) StrategyCreate(ctx echo.Context) error {
	var payload Strategy
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Strategy.Create()
	op.SetName(payload.Name)
	if payload.Parameters != nil {
		op.SetParameters(*payload.Parameters)
	}
	if payload.SortOrder != nil {
		op.SetSortOrder(*payload.SortOrder)
	}
	op.SetFlagEnvironmentID(payload.FlagEnvironmentID)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) StrategyUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Strategy.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Strategy
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetName(payload.Name)
	if payload.Parameters == nil {
		op.ClearParameters()
	} else {
		op.SetParameters(*payload.Parameters)
	}
	if payload.SortOrder == nil {
		var empty int
		op.SetSortOrder(empty)
	} else {
		op.SetSortOrder(*payload.SortOrder)
	}
	op.SetFlagEnvironmentID(payload.FlagEnvironmentID)
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) StrategyDelete(ctx echo.Context, id int) error {
	return h.client.Strategy.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) StrategyList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Strategy.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(strategy.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Name",
			"Parameters",
			"Sort order",
			"Flag environment ID",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Name,
				fmt.Sprint(res[i].Parameters),
				fmt.Sprint(res[i].SortOrder),
				fmt.Sprint(res[i].FlagEnvironmentID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) StrategyGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Strategy.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("name", entity.Name)
	v.Set("parameters", fmt.Sprint(entity.Parameters))
	v.Set("sort_order", fmt.Sprint(entity.SortOrder))
	v.Set("flag_environment_id", fmt.Sprint(entity.FlagEnvironmentID))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) UserCreate(ctx echo.Context) error {
	var payload User
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.User.Create()
	op.SetEmail(payload.Email)
	if payload.Password != nil {
		op.SetPassword(*payload.Password)
	}
	op.SetName(payload.Name)
	if payload.Role != nil {
		op.SetRole(*payload.Role)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) UserUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.User.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload User
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetEmail(payload.Email)
	if payload.Password != nil {
		op.SetPassword(*payload.Password)
	}
	op.SetName(payload.Name)
	if payload.Role == nil {
		var empty user.Role
		op.SetRole(empty)
	} else {
		op.SetRole(*payload.Role)
	}
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) UserDelete(ctx echo.Context, id int) error {
	return h.client.User.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) UserList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.User.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(user.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Email",
			"Name",
			"Role",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Email,
				res[i].Name,
				fmt.Sprint(res[i].Role),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) UserGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.User.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("email", entity.Email)
	v.Set("name", entity.Name)
	v.Set("role", fmt.Sprint(entity.Role))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) getPageAndOffset(ctx echo.Context) (int, int) {
	if page, err := strconv.Atoi(ctx.QueryParam(h.Config.PageQueryKey)); err == nil {
		if page > 1 {
			return page, (page - 1) * h.Config.ItemsPerPage
		}
	}
	return 1, 0
}

func (h *Handler) bind(ctx echo.Context, entity any) error {
	// Echo requires some pre-processing of form values to avoid problems.
	for k, v := range ctx.Request().Form {
		// Remove empty field values so Echo's bind does not fail when trying to parse things like
		// times, etc.
		if len(v) == 1 && len(v[0]) == 0 {
			delete(ctx.Request().Form, k)
			continue
		}

		// Echo expects datetime values to be in a certain format but that does not align with the datetime-local
		// HTML form element format, so we will attempt to convert it here.
		for _, format := range []string{dateTimeFormatNoSeconds, dateTimeFormat} {
			if t, err := time.Parse(format, v[0]); err == nil {
				ctx.Request().Form[k][0] = t.Format(time.RFC3339)
				break
			}
		}
	}
	return ctx.Bind(entity)
}
